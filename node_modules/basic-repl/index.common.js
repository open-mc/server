let text = '', history = [], historyI = -1, selectionI = 0, noinput = true
let inputmode = 0, prefixes = [], handlers = []
const oco = console.log, occ = console.clear, isTTY = process.stdin.isTTY
console.log = (...a) => {
	if(noinput)return oco(...a)
	let lineCount = process.stdout.columns ? Math.ceil((text.length + prefixes[inputmode].length) / process.stdout.columns) : 1
	while(--lineCount)process.stdout.write('\x1b[2K\x1b[1A')
	process.stdout.write("\x1b[2K\x1b[99999D")
	oco(...a)
	process.stdout.write("\x1b[34m"+prefixes[inputmode]+"\x1b[m"+text+(selectionI==text.length?'':'\x1b['+(text.length-selectionI)+'D'))
}
console.clear = () => {
	occ()
	if(!noinput)process.stdout.write("\x1b[34m"+prefixes[inputmode]+"\x1b[m"+text+(selectionI==text.length?'':'\x1b['+(text.length-selectionI)+'D'))
}
if(isTTY)process.stdin.setRawMode(true)
console.warn = (...a) => void(process.stdout.write('\x1b[33m'),console.log(...a),process.stdout.write('\x1b[m'))
console.error = (...a) => void(process.stdout.write('\x1b[31m'),console.log(...a),process.stdout.write('\x1b[m'))
console.info = (...a) => void(process.stdout.write('\x1b[32m'),console.log(...a),process.stdout.write('\x1b[m'))
process.stdin.on("data", async function(key) {
	key += ''
	if(noinput)return
	if(key == '\r'){
		noinput = true
		if(isTTY)oco('')
		else text = key
		historyI = -1
		const _t = text
		if(history.unshift(text) > 1000)history.pop()
		text = ''
		selectionI = 0
		try{await handlers[inputmode](_t)}catch(e){oco("\x1b[31m"+e+"\x1b[m")}
		noinput = false
		process.stdout.write('\x1b[34m'+prefixes[inputmode]+'\x1b[m')
	}else if(key == '\x7F'){
		if(selectionI < 1)return
		let posX = (selectionI + prefixes[inputmode].length) % process.stdout.columns
		if(posX) process.stdout.write('\x1b[1D'+text.slice(selectionI)+' \x1b['+(text.length-selectionI+1)+'D')
		else process.stdout.write(text.slice(selectionI + 1)+' \x1b[999C\x1b['+Math.floor((text.length+prefixes[inputmode].length-selectionI)/process.stdout.columns)+'A'+(text[selectionI] || ' ')+'\x1b[D')
		text = text.slice(0,selectionI-1) + text.slice(selectionI)
		selectionI--
	}else if(key == '\x09'){
		let lineCount = Math.ceil((text.length + prefixes[inputmode].length) / process.stdout.columns)
		while(--lineCount)process.stdout.write('\x1b[2K\x1b[1A')
		inputmode = (inputmode + 1) % prefixes.length
		process.stdout.write("\x1b[2K\x1b[99999D\x1b[34m"+prefixes[inputmode]+"\x1b[m"+text+(selectionI==text.length?'':'\x1b['+(text.length-selectionI)+'D'))
	}else if(key == '\x03'){
		if(!process.emit('SIGINT'))process.exit()
	}else if(key == '\x1b[A'){
		//up
		if(historyI < history.length - 1){
			historyI++
			process.stdout.write('\x1b[2K\x1b[99999D\x1b[34m'+prefixes[inputmode]+'\x1b[m'+history[historyI])
			text = history[historyI]
			selectionI = text.length
		}
	}else if(key == '\x1b[B'){
		//down
		if(historyI > 0){
			historyI--
			process.stdout.write('\x1b[2K\x1b[99999D\x1b[34m'+prefixes[inputmode]+'\x1b[m'+history[historyI])
			text = history[historyI]
			selectionI = text.length
		}
	}else if(key == '\x1b[C'){
		let posX = (selectionI + prefixes[inputmode].length + 1) % process.stdout.columns
		if(selectionI < text.length){
			if(posX)process.stdout.write(key)
			else process.stdout.write('\n')
			selectionI++
		}
	}else if(key == '\x1b[D'){
		if(selectionI > 0){
			process.stdout.write(key)
			selectionI--
		}
	}else if(key.charCodeAt()>=32){process.stdout.write(key+text.slice(selectionI)+(selectionI==text.length?'':'\x1b['+(text.length-selectionI)+'D')), text = text.slice(0,selectionI) + key + text.slice(selectionI); selectionI+=key.length}
})
/**
 * Creates a repl with the specified prefix and handler. If multiple repls are created, you can switch between then with Tab
 * @param {string} prefix prefix
 * @param {Function} handler callback handler
 */
function repl(prefix, handler){
	prefixes.push(prefix)
	handlers.push(handler)
	if(noinput)input()
	return prefixes.length
}
/**
 * Turn on or off input. Omit parameter to toggle
 * @param {Boolean} [bool] Value to set
 */
function input(bool = noinput){
	if(!prefixes.length)return
	noinput = !bool
	if(noinput){
		let lineCount = Math.ceil((text.length + prefixes[inputmode].length) / process.stdout.columns)
		while(--lineCount)process.stdout.write('\x1b[2K\x1b[1A')
		process.stdout.write("\x1b[2K\x1b[99999D")
	}else{
		process.stdout.write("\x1b[2K\x1b[99999D\x1b[34m"+prefixes[inputmode]+"\x1b[m"+text+(selectionI==text.length?'':'\x1b['+(text.length-selectionI)+'D'))
	}
}
module.exports = Object.assign((a,b)=>repl(a+' ',async(a)=>console.log(await b(a))),{repl, input})
